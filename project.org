#+TITLE: Dashboard-Light Project
#+AUTHOR: Олег
#+DATE: 2025-04-05
#+PROPERTY: header-args:python :results output :session *dashboard-light*

* Настройки проекта

** pyproject.toml
Основной файл проекта с зависимостями:

#+begin_src python :tangle pyproject.toml :mkdirp yes
[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "dashboard-light"
version = "0.1.0"
description = "Система мониторинга EKS Deployments & Pods"
readme = "README.md"
requires-python = ">=3.8"
authors = [
    {name = "Олег", email = "oleg@example.com"},
]
dependencies = [
    # Веб-сервер и маршрутизация
    "fastapi>=0.92.0",
    "uvicorn>=0.20.0",
    "jinja2>=3.1.2",
    "aiofiles>=23.1.0",

    # Kubernetes клиент
    "kubernetes>=28.1.0",

    # Работа с конфигурацией
    "pyyaml>=6.0.1",
    "pydantic>=2.4.2",

    # Аутентификация OAuth
    "authlib>=1.2.1",
    "itsdangerous>=2.1.2",
    "python-jose>=3.3.0",

    # HTTP клиент
    "httpx>=0.24.1",

    # Утилиты
    "pydantic-settings>=2.0.3",
    "toolz>=0.12.0",
    "more-itertools>=10.1.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=7.3.1",
    "black>=23.3.0",
    "isort>=5.12.0",
    "mypy>=1.3.0",
    "ruff>=0.0.269",
]

[project.scripts]
dashboard-light = "dashboard_light.core:main"

[tool.black]
line-length = 88
target-version = ["py38"]

[tool.isort]
profile = "black"
line_length = 88

[tool.mypy]
python_version = "3.8"
warn_return_any = true
warn_unused_configs = true

[tool.ruff]
line-length = 88
target-version = "py38"
select = ["E", "F", "B", "I"]
#+end_src

* Ядро приложения

** src/dashboard_light/__init__.py
Инициализация пакета:

#+begin_src python :tangle src/dashboard_light/__init__.py :mkdirp yes
"""Dashboard-Light - Система мониторинга EKS Deployments & Pods."""

__version__ = "0.1.0"
#+end_src

** src/dashboard_light/core.py
Точка входа в приложение:

#+begin_src python :tangle src/dashboard_light/core.py :mkdirp yes
"""Точка входа в приложение Dashboard-Light."""

import logging
import signal
import sys
from functools import partial
from typing import Any, Callable, Dict, List, Optional

from dashboard_light.config import core as config
from dashboard_light.k8s import core as k8s
from dashboard_light.web import core as web

# Настройка логирования
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger(__name__)


def setup_signal_handlers(cleanup_func: Callable[[], None]) -> None:
    """Настройка обработчиков сигналов для корректного завершения приложения."""
    for sig in (signal.SIGTERM, signal.SIGINT):
        signal.signal(sig, lambda signum, frame: cleanup_func())


def start_app() -> Dict[str, Any]:
    """Запуск всех компонентов приложения.

    Returns:
        Dict[str, Any]: Словарь с компонентами приложения
    """
    logger.info("Запуск Dashboard-Light...")

    try:
        # Загрузка конфигурации
        app_config = config.load_config()
        logger.info("Конфигурация загружена успешно")

        # Инициализация Kubernetes клиента
        k8s_client = k8s.create_k8s_client(app_config)
        logger.info("Kubernetes клиент инициализирован")

        # Запуск веб-сервера
        web_server = web.start_server(app_config, k8s_client)
        logger.info("Веб-сервер запущен")

        return {
            "config": app_config,
            "k8s_client": k8s_client,
            "web_server": web_server,
        }
    except Exception as e:
        logger.error(f"Ошибка при запуске приложения: {str(e)}")
        sys.exit(1)


def stop_app(components: Dict[str, Any]) -> None:
    """Остановка всех компонентов приложения.

    Args:
        components: Словарь с компонентами приложения
    """
    logger.info("Остановка Dashboard-Light...")

    # Остановка веб-сервера
    web_server = components.get("web_server")
    if web_server:
        web.stop_server(web_server)
        logger.info("Веб-сервер остановлен")

    # Очистка ресурсов K8s клиента
    k8s_client = components.get("k8s_client")
    if k8s_client:
        k8s.cleanup_k8s_client(k8s_client)
        logger.info("Kubernetes клиент остановлен")

    logger.info("Приложение Dashboard-Light остановлено")


def main() -> None:
    """Основная функция для запуска приложения."""
    components = start_app()

    # Настройка обработчиков сигналов для корректного завершения
    setup_signal_handlers(partial(stop_app, components))

    try:
        # Бесконечный цикл для поддержания работы приложения
        # до получения сигнала остановки
        import time
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        logger.info("Получен сигнал остановки приложения")
    finally:
        stop_app(components)


if __name__ == "__main__":
    main()
#+end_src

* Работа с конфигурацией

** src/dashboard_light/config/__init__.py
Инициализация модуля конфигурации:

#+begin_src python :tangle src/dashboard_light/config/__init__.py :mkdirp yes
"""Модуль для работы с конфигурацией приложения."""
#+end_src

** src/dashboard_light/config/core.py
Загрузка и управление конфигурацией:

#+begin_src python :tangle src/dashboard_light/config/core.py :mkdirp yes
"""Основные функции для работы с конфигурацией приложения."""

import logging
import os
from functools import lru_cache
from pathlib import Path
from typing import Any, Dict, List, Optional, Union

import yaml
from dashboard_light.config import schema
from dashboard_light.utils import core as utils

logger = logging.getLogger(__name__)

CONFIG_CACHE: Dict[str, Any] = {}


def load_config_file(config_path: str) -> Dict[str, Any]:
    """Загрузка конфигурации из файла.

    Args:
        config_path: Путь к файлу конфигурации

    Returns:
        Dict[str, Any]: Загруженная конфигурация

    Raises:
        FileNotFoundError: Если файл конфигурации не найден
        ValueError: Если произошла ошибка при парсинге конфигурации
    """
    try:
        config_file = Path(config_path)
        if not config_file.exists():
            raise FileNotFoundError(f"Файл конфигурации не найден: {config_path}")

        with open(config_file, 'r', encoding='utf-8') as f:
            config_data = yaml.safe_load(f)

        logger.info(f"Конфигурация загружена из файла: {config_path}")
        return config_data
    except FileNotFoundError as e:
        logger.error(f"Файл конфигурации не найден: {config_path}")
        raise e
    except yaml.YAMLError as e:
        logger.error(f"Ошибка парсинга YAML конфигурации: {str(e)}")
        raise ValueError(f"Ошибка парсинга YAML конфигурации: {str(e)}")
    except Exception as e:
        logger.error(f"Непредвиденная ошибка при загрузке конфигурации: {str(e)}")
        raise


def substitute_env_vars(config: Dict[str, Any]) -> Dict[str, Any]:
    """Подстановка переменных окружения в конфигурацию.

    Ищет значения вида "ENV:VAR_NAME" или "ENV:VAR_NAME:default" и
    заменяет их на значения соответствующих переменных окружения.

    Args:
        config: Конфигурация для обработки

    Returns:
        Dict[str, Any]: Обработанная конфигурация
    """
    def process_value(value: Any) -> Any:
        if isinstance(value, str) and value.startswith("ENV:"):
            # Парсинг строки вида "ENV:VAR_NAME" или "ENV:VAR_NAME:default"
            parts = value[4:].split(":", 1)
            env_name = parts[0]
            default = parts[1] if len(parts) > 1 else None

            # Получение значения из переменной окружения
            return os.environ.get(env_name, default)
        elif isinstance(value, dict):
            return {k: process_value(v) for k, v in value.items()}
        elif isinstance(value, list):
            return [process_value(item) for item in value]
        else:
            return value

    return process_value(config)


@lru_cache(maxsize=1)
def load_config() -> Dict[str, Any]:
    """Загрузка конфигурации с учетом переменных окружения.

    Returns:
        Dict[str, Any]: Загруженная и валидированная конфигурация
    """
    global CONFIG_CACHE

    # Если конфигурация уже в кэше, возвращаем её
    if CONFIG_CACHE:
        return CONFIG_CACHE

    # Определение пути к файлу конфигурации
    config_path = os.environ.get("CONFIG_PATH", "resources/config.yaml")

    # Загрузка конфигурации из файла
    config_data = load_config_file(config_path)

    # Подстановка переменных окружения
    config_data = substitute_env_vars(config_data)

    # Валидация конфигурации по схеме
    config_data = schema.validate_config(config_data)

    # Сохранение в кэше
    CONFIG_CACHE = config_data

    return config_data


def get_in_config(path: List[str], default: Any = None) -> Any:
    """Получение значения из конфигурации по пути ключей.

    Args:
        path: Список ключей для доступа к вложенным значениям
        default: Значение по умолчанию, если путь не найден

    Returns:
        Any: Найденное значение или значение по умолчанию
    """
    config_data = load_config()
    return utils.get_in(config_data, path, default)


def reload_config() -> Dict[str, Any]:
    """Перезагрузка конфигурации из файла.

    Returns:
        Dict[str, Any]: Обновленная конфигурация
    """
    global CONFIG_CACHE
    CONFIG_CACHE = {}  # Очистка кэша
    load_config.cache_clear()  # Очистка кэша LRU
    return load_config()  # Повторная загрузка
#+end_src

** src/dashboard_light/config/schema.py
Схема валидации конфигурации:

#+begin_src python :tangle src/dashboard_light/config/schema.py :mkdirp yes
"""Схема валидации конфигурации приложения."""

import logging
import re
from typing import Any, Dict, List, Optional, Union

from pydantic import BaseModel, Field, field_validator, model_validator

logger = logging.getLogger(__name__)


class RoleGitlabGroups(BaseModel):
    """Модель для групп GitLab, связанных с ролью."""

    gitlab_groups: List[str] = Field(default_factory=list)


class RolePermissions(BaseModel):
    """Модель для прав доступа, связанных с ролью."""

    menu_items: List[str] = Field(default_factory=list)
    allowed_namespace_patterns: List[str] = Field(default_factory=list)
    allowed_clusters: List[str] = Field(default_factory=list)


class StatusColors(BaseModel):
    """Модель для цветов статусов."""

    class DeploymentColors(BaseModel):
        """Цвета для статусов деплойментов."""

        healthy: str = "#28a745"
        progressing: str = "#ffc107"
        scaled_zero: str = "#6c757d"
        error: str = "#dc3545"

    class PodColors(BaseModel):
        """Цвета для статусов подов."""

        running: str = "#28a745"
        succeeded: str = "#17a2b8"
        pending: str = "#ffc107"
        failed: str = "#dc3545"
        terminating: str = "#6c757d"

    deployment: DeploymentColors = Field(default_factory=DeploymentColors)
    pod: PodColors = Field(default_factory=PodColors)


class UIConfig(BaseModel):
    """Модель для конфигурации UI."""

    refresh_interval_seconds: int = 15
    status_colors: StatusColors = Field(default_factory=StatusColors)


class MenuItem(BaseModel):
    """Модель для пункта меню."""

    id: str
    title: str
    icon: str
    required_role: str


class AuthConfig(BaseModel):
    """Модель для конфигурации аутентификации."""

    provider: str
    gitlab_url: str
    client_id: str
    client_secret_env: str
    redirect_uri: str
    roles: Dict[str, RoleGitlabGroups]
    permissions: Dict[str, RolePermissions]
    allow_anonymous_access: bool = False
    anonymous_role: Optional[str] = None

    @model_validator(mode='after')
    def check_anonymous_role(self) -> 'AuthConfig':
        """Проверка, что анонимная роль существует, если включен анонимный доступ."""
        if self.allow_anonymous_access and not self.anonymous_role:
            raise ValueError("Если allow_anonymous_access=True, нужно указать anonymous_role")

        if self.allow_anonymous_access and self.anonymous_role not in self.roles:
            raise ValueError(f"Указанная anonymous_role '{self.anonymous_role}' не существует в списке ролей")

        return self


class CacheConfig(BaseModel):
    """Модель для конфигурации кэширования."""

    default_ttl: int = 30
    ttl: Dict[str, int] = Field(default_factory=dict)


class TestConfig(BaseModel):
    """Модель для конфигурации тестирования."""

    namespace_patterns: List[str] = Field(default_factory=lambda: ["default", "kube-system"])


class AppConfig(BaseModel):
    """Основная модель конфигурации приложения."""

    auth: AuthConfig
    ui: UIConfig = Field(default_factory=UIConfig)
    menu: List[MenuItem] = Field(default_factory=list)
    cache: CacheConfig = Field(default_factory=CacheConfig)
    test: TestConfig = Field(default_factory=TestConfig)


def validate_config(config_data: Dict[str, Any]) -> Dict[str, Any]:
    """Валидация конфигурации по схеме.

    Args:
        config_data: Данные конфигурации для проверки

    Returns:
        Dict[str, Any]: Проверенные данные конфигурации

    Raises:
        ValueError: Если конфигурация не соответствует схеме
    """
    try:
        validated_config = AppConfig(**config_data)
        return validated_config.model_dump()
    except Exception as e:
        logger.error(f"Ошибка валидации конфигурации: {str(e)}")
        raise ValueError(f"Ошибка валидации конфигурации: {str(e)}")
#+end_src

* Kubernetes API клиент

** src/dashboard_light/k8s/__init__.py
Инициализация модуля Kubernetes:

#+begin_src python :tangle src/dashboard_light/k8s/__init__.py :mkdirp yes
"""Модуль для работы с Kubernetes API."""
#+end_src

** src/dashboard_light/k8s/core.py
Инициализация K8s клиента:

#+begin_src python :tangle src/dashboard_light/k8s/core.py :mkdirp yes
  """Основные функции для работы с Kubernetes API."""

  import logging
  import os
  from typing import Any, Dict, Optional

  from kubernetes import client, config

  logger = logging.getLogger(__name__)


  def create_k8s_client(app_config: Dict[str, Any]) -> Dict[str, Any]:
      """Создание Kubernetes API клиента.

      При запуске внутри кластера будет использовать serviceAccount,
      при запуске вне кластера - kubeconfig или переменные окружения.

      Args:
          app_config: Конфигурация приложения

      Returns:
          Dict[str, Any]: Словарь с Kubernetes клиентом и API
      """
      try:
          logger.info("Инициализация Kubernetes API клиента...")
          use_mock = os.environ.get("K8S_MOCK", "").lower() in ["true", "1", "yes", "y"]
          logger.info(f"Режим эмуляции K8s (MOCK): {use_mock}")

          if use_mock:
              logger.info("Используется MOCK-клиент Kubernetes")
              api_client = client.ApiClient()
          else:
              logger.info("Подключение к кластеру Kubernetes...")
              try:
                  # Пытаемся загрузить конфигурацию из кластера
                  config.load_incluster_config()
                  logger.info("Успешно загружена конфигурация из кластера")
                  api_client = client.ApiClient()
              except Exception as e:
                  logger.info(f"Не удалось подключиться изнутри кластера: {str(e)}. "
                             "Пробуем локальную конфигурацию")
                  # Пытаемся загрузить конфигурацию из kubeconfig
                  config.load_kube_config()
                  logger.info("Успешно загружена локальная конфигурация")
                  api_client = client.ApiClient()

          # Создание API клиентов для различных ресурсов
          core_v1_api = client.CoreV1Api(api_client)
          apps_v1_api = client.AppsV1Api(api_client)
          custom_objects_api = client.CustomObjectsApi(api_client)

          # Проверка доступа к API
          try:
              namespaces = core_v1_api.list_namespace()
              logger.info(f"Kubernetes API аутентификация успешна. "
                         f"Найдено неймспейсов: {len(namespaces.items)}")
          except Exception as e:
              logger.warning(f"Не удалось получить список неймспейсов: {str(e)}")

          return {
              "api_client": api_client,
              "core_v1_api": core_v1_api,
              "apps_v1_api": apps_v1_api,
              "custom_objects_api": custom_objects_api,
          }
      except Exception as e:
          logger.error(f"Ошибка создания Kubernetes API клиента: {str(e)}")
          # Возвращаем минимальный набор для работы в режиме эмуляции
          api_client = client.ApiClient()
          return {
              "api_client": api_client,
              "core_v1_api": client.CoreV1Api(api_client),
              "apps_v1_api": client.AppsV1Api(api_client),
              "custom_objects_api": client.CustomObjectsApi(api_client),
          }


  def cleanup_k8s_client(k8s_client: Dict[str, Any]) -> None:
      """Очистка ресурсов Kubernetes клиента.

      Args:
          k8s_client: Словарь с Kubernetes клиентом и API
      """
      if k8s_client and "api_client" in k8s_client:
          api_client = k8s_client["api_client"]
          if api_client:
              api_client.close()
              logger.info("Kubernetes API клиент закрыт")
#+end_src

** src/dashboard_light/k8s/cache.py
Кэширование запросов к K8s:

#+begin_src python :tangle src/dashboard_light/k8s/cache.py :mkdirp yes
"""Модуль для кэширования результатов запросов к Kubernetes API."""

import logging
import time
from functools import wraps
from threading import RLock
from typing import Any, Callable, Dict, Optional, TypeVar

from dashboard_light.config.core import get_in_config

logger = logging.getLogger(__name__)

# Типовая переменная для обобщенных функций
T = TypeVar('T')

# Глобальный кэш
cache_store: Dict[str, Dict[str, Any]] = {}
cache_lock = RLock()

# Значение TTL по умолчанию в секундах
DEFAULT_TTL_SECONDS = 30


def get_cache_ttl(cache_key: str) -> int:
    """Получение TTL для кэша из конфигурации или значения по умолчанию.

    Args:
        cache_key: Ключ кэша

    Returns:
        int: Время жизни записи в кэше в секундах
    """
    path = ["cache", "ttl", cache_key]
    ttl = get_in_config(path)

    if ttl is None:
        ttl = get_in_config(["cache", "default_ttl"], DEFAULT_TTL_SECONDS)

    return ttl


def cache_get(cache_key: str) -> Optional[Any]:
    """Получение значения из кэша с проверкой его актуальности.

    Args:
        cache_key: Ключ кэша

    Returns:
        Optional[Any]: Значение из кэша или None, если запись не найдена или устарела
    """
    with cache_lock:
        cached_item = cache_store.get(cache_key)

        if cached_item:
            ttl = get_cache_ttl(cache_key)
            current_time = time.time()
            update_time = cached_item.get("update_time", 0)
            age_seconds = current_time - update_time

            if age_seconds < ttl:
                logger.debug(f"Используются кэшированные данные для: {cache_key}")
                return cached_item.get("value")
            else:
                logger.debug(f"Кэш устарел: {cache_key}, возраст: {age_seconds:.2f} сек")
                return None

        return None


def cache_put(cache_key: str, value: Any) -> Any:
    """Сохранение значения в кэше с текущим временем.

    Args:
        cache_key: Ключ кэша
        value: Значение для сохранения

    Returns:
        Any: Сохраненное значение
    """
    with cache_lock:
        cache_store[cache_key] = {
            "value": value,
            "update_time": time.time()
        }
        logger.debug(f"Обновление кэша для: {cache_key}")
        return value


def with_cache(cache_key_prefix: str):
    """Декоратор для получения данных с использованием кэширования.

    Args:
        cache_key_prefix: Префикс ключа кэша

    Returns:
        Callable: Декорированная функция
    """
    def decorator(func: Callable[..., T]) -> Callable[..., T]:
        @wraps(func)
        def wrapper(*args, **kwargs) -> T:
            # Формирование ключа кэша из префикса и аргументов
            arg_str = "_".join(str(arg) for arg in args)
            kwarg_str = "_".join(f"{k}={v}" for k, v in sorted(kwargs.items()))
            cache_key = f"{cache_key_prefix}_{arg_str}_{kwarg_str}"

            # Пытаемся получить данные из кэша
            cached_value = cache_get(cache_key)
            if cached_value is not None:
                return cached_value

            # Если в кэше нет, вызываем оригинальную функцию
            result = func(*args, **kwargs)
            return cache_put(cache_key, result)

        return wrapper

    return decorator


def invalidate_cache(cache_key: str) -> None:
    """Инвалидация кэша для указанного ключа.

    Args:
        cache_key: Ключ кэша для инвалидации
    """
    with cache_lock:
        if cache_key in cache_store:
            del cache_store[cache_key]
            logger.debug(f"Кэш инвалидирован для: {cache_key}")


def invalidate_by_prefix(prefix: str) -> None:
    """Инвалидация всех записей кэша, начинающихся с указанного префикса.

    Args:
        prefix: Префикс ключа кэша
    """
    with cache_lock:
        keys_to_delete = [k for k in cache_store if k.startswith(prefix)]
        for key in keys_to_delete:
            del cache_store[key]

        if keys_to_delete:
            logger.debug(f"Инвалидировано {len(keys_to_delete)} записей кэша с префиксом: {prefix}")


def invalidate_all() -> None:
    """Полная инвалидация кэша."""
    with cache_lock:
        cache_store.clear()
        logger.info("Весь кэш очищен")


def initialize_cache() -> None:
    """Инициализация конфигурации кэша."""
    logger.info("Инициализация конфигурации кэша")
    default_ttl = get_in_config(["cache", "default_ttl"], DEFAULT_TTL_SECONDS)
    logger.info(f"Время жизни кэша по умолчанию: {default_ttl} сек")
#+end_src

** src/dashboard_light/k8s/namespaces.py
Работа с Namespaces:

#+begin_src python :tangle src/dashboard_light/k8s/namespaces.py :mkdirp yes
"""Модуль для работы с неймспейсами Kubernetes."""

import logging
import re
from typing import Any, Dict, List, Optional

from kubernetes import client
from kubernetes.client.exceptions import ApiException

from dashboard_light.k8s.cache import with_cache

logger = logging.getLogger(__name__)

# Тестовые данные для режима разработки
TEST_NAMESPACES = [
    {"name": "default", "phase": "Active"},
    {"name": "kube-system", "phase": "Active"},
    {"name": "project-app1-staging", "phase": "Active"},
    {"name": "project-app2-prod", "phase": "Active"},
]


@with_cache("namespaces")
def list_namespaces(k8s_client: Dict[str, Any]) -> List[Dict[str, Any]]:
    """Получение списка всех неймспейсов в кластере.

    Args:
        k8s_client: Словарь с Kubernetes клиентом и API

    Returns:
        List[Dict[str, Any]]: Список данных о неймспейсах
    """
    try:
        logger.info("K8S: Запрос списка неймспейсов из Kubernetes API")
        core_v1_api = k8s_client.get("core_v1_api")

        if not core_v1_api:
            logger.warning("K8S: API клиент не инициализирован, возвращаем тестовые данные")
            return TEST_NAMESPACES

        result = core_v1_api.list_namespace()

        if not result or not result.items:
            logger.warning("K8S: Результат запроса неймспейсов пуст, возвращаем тестовые данные")
            return TEST_NAMESPACES

        items = result.items
        logger.info(f"K8S: Получено элементов: {len(items)}")

        # Преобразование в словари с нужными полями
        namespaces = [
            {
                "name": item.metadata.name,
                "phase": item.status.phase,
                "created": item.metadata.creation_timestamp.isoformat()
                    if item.metadata.creation_timestamp else None,
                "labels": item.metadata.labels if item.metadata.labels else {},
            }
            for item in items
        ]

        return namespaces
    except ApiException as e:
        logger.error(f"K8S: Ошибка API при получении списка неймспейсов: {str(e)}")
        return TEST_NAMESPACES
    except Exception as e:
        logger.error(f"K8S: Ошибка получения списка неймспейсов: {str(e)}")
        return TEST_NAMESPACES


def filter_namespaces_by_pattern(namespaces: List[Dict[str, Any]],
                                patterns: List[str]) -> List[Dict[str, Any]]:
    """Фильтрация неймспейсов по списку регулярных выражений.

    Args:
        namespaces: Список данных о неймспейсах
        patterns: Список регулярных выражений для фильтрации

    Returns:
        List[Dict[str, Any]]: Отфильтрованный список данных о неймспейсах
    """
    # Если паттерны пустые или есть ".*", возвращаем все неймспейсы
    if not patterns or any(pattern == ".*" for pattern in patterns):
        return namespaces

    # Компиляция регулярных выражений для оптимизации
    compiled_patterns = [re.compile(pattern) for pattern in patterns]

    # Фильтрация неймспейсов
    filtered = [
        namespace for namespace in namespaces
        if any(pattern.match(namespace["name"]) for pattern in compiled_patterns)
    ]

    return filtered


def list_filtered_namespaces(k8s_client: Dict[str, Any],
                           patterns: List[str]) -> List[Dict[str, Any]]:
    """Получение отфильтрованных неймспейсов по списку регулярных выражений.

    Args:
        k8s_client: Словарь с Kubernetes клиентом и API
        patterns: Список регулярных выражений для фильтрации

    Returns:
        List[Dict[str, Any]]: Отфильтрованный список данных о неймспейсах
    """
    all_namespaces = list_namespaces(k8s_client)
    return filter_namespaces_by_pattern(all_namespaces, patterns)
#+end_src

** src/dashboard_light/k8s/deployments.py
Работа с Deployments:

#+begin_src python :tangle src/dashboard_light/k8s/deployments.py :mkdirp yes
"""Модуль для работы с деплойментами Kubernetes."""

import logging
import re
from typing import Any, Dict, List, Optional

from kubernetes import client
from kubernetes.client.exceptions import ApiException

from dashboard_light.k8s.cache import with_cache

logger = logging.getLogger(__name__)


@with_cache("deployments")
def list_deployments_for_namespace(k8s_client: Dict[str, Any], namespace: str) -> List[Dict[str, Any]]:
    """Получение списка Deployments в указанном пространстве имен.

    Args:
        k8s_client: Словарь с Kubernetes клиентом и API
        namespace: Имя пространства имен

    Returns:
        List[Dict[str, Any]]: Список данных о Deployments
    """
    try:
        apps_v1_api = k8s_client.get("apps_v1_api")

        if not apps_v1_api:
            logger.warning(f"K8S: API клиент для Apps/v1 не инициализирован, "
                          f"возвращаем пустой список для {namespace}")
            return []

        result = apps_v1_api.list_namespaced_deployment(namespace=namespace)

        if not result or not result.items:
            logger.info(f"K8S: Нет Deployments в неймспейсе {namespace}")
            return []

        # Преобразование в словари с нужными полями
        deployments = []
        for item in result.items:
            metadata = item.metadata
            spec = item.spec
            status = item.status

            # Получение информации о контейнерах
            containers = []
            if spec.template and spec.template.spec and spec.template.spec.containers:
                containers = spec.template.spec.containers

            main_container = containers[0] if containers else None

            # Формирование данных о деплойменте
            deployment_data = {
                "name": metadata.name,
                "namespace": metadata.namespace,
                "replicas": {
                    "desired": spec.replicas,
                    "ready": status.ready_replicas if status.ready_replicas else 0,
                    "available": status.available_replicas if status.available_replicas else 0,
                    "updated": status.updated_replicas if status.updated_replicas else 0,
                }
            }

            # Добавление информации о главном контейнере, если он есть
            if main_container:
                image = main_container.image
                image_tag = image.split(":")[-1] if ":" in image else "latest"

                deployment_data["main_container"] = {
                    "name": main_container.name,
                    "image": image,
                    "image_tag": image_tag,
                }

            # Добавление лейблов
            if metadata.labels:
                deployment_data["labels"] = metadata.labels

            deployments.append(deployment_data)

        return deployments
    except ApiException as e:
        logger.error(f"K8S: Ошибка API при получении Deployments: {str(e)}")
        return []
    except Exception as e:
        logger.error(f"K8S: Ошибка получения списка Deployments: {str(e)}")
        return []


def list_deployments_multi_ns(k8s_client: Dict[str, Any], namespaces: List[str]) -> List[Dict[str, Any]]:
    """Получение списка Deployments для нескольких пространств имен.

    Args:
        k8s_client: Словарь с Kubernetes клиентом и API
        namespaces: Список имен пространств имен

    Returns:
        List[Dict[str, Any]]: Объединенный список данных о Deployments
    """
    deployments = []
    for namespace in namespaces:
        namespace_deployments = list_deployments_for_namespace(k8s_client, namespace)
        deployments.extend(namespace_deployments)

    return deployments


def get_deployment_status(deployment: Dict[str, Any]) -> str:
    """Определение статуса Deployment на основе его параметров.

    Args:
        deployment: Данные о Deployment

    Returns:
        str: Статус Deployment (healthy, progressing, scaled_zero, error)
    """
    desired = deployment.get("replicas", {}).get("desired")
    ready = deployment.get("replicas", {}).get("ready", 0)

    if desired is None:
        return "error"
    elif desired == 0:
        return "scaled_zero"
    elif ready == desired:
        return "healthy"
    else:
        return "progressing"
#+end_src

* Утилиты

** src/dashboard_light/utils/__init__.py
Инициализация модуля утилит:

#+begin_src python :tangle src/dashboard_light/utils/__init__.py :mkdirp yes
"""Модуль с утилитарными функциями."""
#+end_src

** src/dashboard_light/utils/core.py
Общие утилиты:

#+begin_src python :tangle src/dashboard_light/utils/core.py :mkdirp yes
"""Основные утилитарные функции."""

import logging
import os
import re
from functools import reduce
from typing import Any, Callable, Dict, List, Optional, Tuple, TypeVar, Union

logger = logging.getLogger(__name__)

# Типовая переменная для обобщенных функций
T = TypeVar('T')


def deep_merge(d1: Dict[str, Any], d2: Dict[str, Any]) -> Dict[str, Any]:
    """Глубокое объединение вложенных словарей.

    Если ключи имеют словари в качестве значений, они рекурсивно объединяются.
    В противном случае значение из второго словаря перезаписывает значение из первого.

    Args:
        d1: Первый словарь
        d2: Второй словарь

    Returns:
        Dict[str, Any]: Объединенный словарь
    """
    result = d1.copy()

    for key, value in d2.items():
        if key in result and isinstance(result[key], dict) and isinstance(value, dict):
            result[key] = deep_merge(result[key], value)
        else:
            result[key] = value

    return result


def get_in(data: Dict[str, Any], keys: List[str], default: Any = None) -> Any:
    """Получение значения из вложенного словаря по пути ключей.

    Args:
        data: Словарь данных
        keys: Список ключей для доступа к вложенным значениям
        default: Значение по умолчанию, если путь не найден

    Returns:
        Any: Найденное значение или значение по умолчанию
    """
    try:
        return reduce(lambda d, k: d.get(k, {}), keys[:-1], data).get(keys[-1], default)
    except (AttributeError, IndexError):
        return default


def dissoc_in(data: Dict[str, Any], keys: List[str]) -> Dict[str, Any]:
    """Удаляет значение по пути ключей в словаре.

    Args:
        data: Словарь данных
        keys: Список ключей для доступа к вложенным значениям

    Returns:
        Dict[str, Any]: Обновленный словарь
    """
    if not keys:
        return data

    result = data.copy()

    if len(keys) == 1:
        if keys[0] in result:
            del result[keys[0]]
    else:
        sub_dict = get_in(data, keys[:-1])
        if isinstance(sub_dict, dict) and keys[-1] in sub_dict:
            sub_dict_copy = sub_dict.copy()
            del sub_dict_copy[keys[-1]]

            # Обновление исходного словаря
            current = result
            for key in keys[:-2]:
                current = current.setdefault(key, {})
            current[keys[-2]] = sub_dict_copy

    return result


def format_error(e: Exception, context: Dict[str, Any] = None) -> Dict[str, Any]:
    """Форматирование информации об ошибке для логирования.

    Args:
        e: Объект исключения
        context: Дополнительный контекст ошибки

    Returns:
        Dict[str, Any]: Отформатированная информация об ошибке
    """
    error_info = {
        "error_message": str(e),
        "error_type": type(e).__name__,
        "traceback": str(e.__traceback__),
    }

    if context:
        error_info.update(context)

    return error_info


def parse_int(s: str) -> Optional[int]:
    """Безопасное преобразование строки в целое число.

    Args:
        s: Строка для преобразования

    Returns:
        Optional[int]: Преобразованное число или None при ошибке
    """
    try:
        return int(s.strip())
    except (ValueError, AttributeError, TypeError):
        return None


def env_value(name: str, default: Any = None) -> Any:
    """Получение значение из переменной окружения с поддержкой значения по умолчанию.

    Args:
        name: Имя переменной окружения
        default: Значение по умолчанию

    Returns:
        Any: Значение переменной окружения или значение по умолчанию
    """
    return os.environ.get(name, default)


def parse_boolean(value: Union[str, bool, int]) -> bool:
    """Преобразование значения в булево значение.

    Args:
        value: Значение для преобразования

    Returns:
        bool: Преобразованное булево значение
    """
    if isinstance(value, bool):
        return value

    if isinstance(value, int):
        return value != 0

    if isinstance(value, str):
        return value.lower().strip() in {"true", "yes", "1", "y", "t"}

    return bool(value)


def sanitize_filename(filename: str) -> str:
    """Очистка имени файла от недопустимых символов.

    Args:
        filename: Имя файла для очистки

    Returns:
        str: Очищенное имя файла
    """
    # Замена недопустимых символов на подчеркивание
    sanitized = re.sub(r'[^a-zA-Z0-9\-_.]', '_', filename)
    # Замена множественных подчеркиваний на одно
    sanitized = re.sub(r'_{2,}', '_', sanitized)
    return sanitized


def human_readable_size(size_bytes: int) -> str:
    """Преобразование размера в байтах в человеко-читаемый формат.

    Args:
        size_bytes: Размер в байтах

    Returns:
        str: Человеко-читаемый размер
    """
    units = ['B', 'KB', 'MB', 'GB', 'TB']

    unit_index = 0
    value = float(size_bytes)

    while value >= 1024 and unit_index < len(units) - 1:
        value /= 1024
        unit_index += 1

    return f"{value:.2f} {units[unit_index]}"


def compose(*funcs: Callable) -> Callable:
    """Композиция функций (в стиле функционального программирования).

    Создает функцию, которая является композицией переданных функций.
    (compose(f, g, h))(x) эквивалентно f(g(h(x))).

    Args:
        *funcs: Набор функций для композиции

    Returns:
        Callable: Композиция функций
    """
    def compose_two(f: Callable, g: Callable) -> Callable:
        return lambda x: f(g(x))

    if not funcs:
        return lambda x: x

    return reduce(compose_two, funcs)


def pipe(value: Any, *funcs: Callable) -> Any:
    """Применение цепочки функций к значению (в стиле функционального программирования).

    Args:
        value: Начальное значение
        *funcs: Функции для применения

    Returns:
        Any: Результат применения всех функций
    """
    return reduce(lambda v, f: f(v), funcs, value)
#+end_src

** src/dashboard_light/utils/logging.py
Настройка логирования:

#+begin_src python :tangle src/dashboard_light/utils/logging.py :mkdirp yes
"""Модуль для настройки и управления логированием."""

import functools
import logging
import os
import time
from contextlib import contextmanager
from typing import Any, Callable, Dict, Generator, Optional, TypeVar

T = TypeVar('T')

logger = logging.getLogger(__name__)


def configure_logging(level: Optional[str] = None) -> None:
    """Настройка логирования на основе конфигурации.

    Args:
        level: Уровень логирования
    """
    if level is None:
        level = os.environ.get("LOG_LEVEL", "INFO")

    numeric_level = getattr(logging, level.upper(), logging.INFO)

    # Настройка корневого логгера
    logging.basicConfig(
        level=numeric_level,
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    )

    # Установка уровня логирования для корневого логгера
    logging.getLogger().setLevel(numeric_level)

    logger.info(f"Уровень логирования установлен: {level.upper()}")


def set_logger_level(logger_name: str, level: str) -> None:
    """Установка уровня логирования для конкретного логгера.

    Args:
        logger_name: Имя логгера
        level: Уровень логирования
    """
    numeric_level = getattr(logging, level.upper(), logging.INFO)
    logging.getLogger(logger_name).setLevel(numeric_level)
    logger.info(f"Уровень логирования для {logger_name} установлен: {level.upper()}")


@contextmanager
def log_timing(message: str, level: int = logging.INFO) -> Generator[None, None, None]:
    """Контекстный менеджер для измерения времени выполнения блока кода.

    Args:
        message: Сообщение для логирования
        level: Уровень логирования

    Yields:
        None
    """
    start_time = time.time()
    try:
        yield
    finally:
        duration = time.time() - start_time
        logger.log(level, f"{message} (выполнено за {duration:.3f} сек)")


def with_logging(message: str, level: int = logging.INFO) -> Callable:
    """Декоратор для логирования времени выполнения функции.

    Args:
        message: Сообщение для логирования
        level: Уровень логирования

    Returns:
        Callable: Декорированная функция
    """
    def decorator(func: Callable[..., T]) -> Callable[..., T]:
        @functools.wraps(func)
        def wrapper(*args, **kwargs) -> T:
            with log_timing(f"{message} - {func.__name__}", level):
                return func(*args, **kwargs)
        return wrapper
    return decorator


@contextmanager
def error_logging(context: Dict[str, Any] = None) -> Generator[None, None, None]:
    """Контекстный менеджер для логирования ошибок при выполнении блока кода.

    Args:
        context: Дополнительный контекст для логирования при ошибке

    Yields:
        None
    """
    try:
        yield
    except Exception as e:
        error_context = {"message": str(e)}
        if context:
            error_context.update(context)

        logger.exception(f"Ошибка: {error_context}")
        raise


# Предопределенные декораторы для удобства
debug_timing = functools.partial(with_logging, level=logging.DEBUG)
info_timing = functools.partial(with_logging, level=logging.INFO)
warn_timing = functools.partial(with_logging, level=logging.WARNING)
#+end_src

* Пример конфигурации

** resources/config.yaml
Пример конфигурационного файла:

#+begin_src yaml :tangle resources/config.yaml :mkdirp yes
# Пример конфигурации dashboard-light
auth:
  provider: gitlab
  gitlab_url: "https://gitlab.example.com"
  client_id: "your-gitlab-client-id"
  client_secret_env: "GITLAB_CLIENT_SECRET"
  redirect_uri: "https://dashboard.example.com/auth/callback"

  # Роли и группы GitLab
  roles:
    viewer:
      gitlab_groups: ["developers", "qa"]
    admin:
      gitlab_groups: ["devops-team"]

  # Права по ролям
  permissions:
    viewer:
      menu_items: ["status"]
      allowed_namespace_patterns: ["^project-.*-staging$", "^common-.*"]
      allowed_clusters: ["staging-cluster"]
    admin:
      menu_items: ["status", "admin_settings"]
      allowed_namespace_patterns: [".*"]
      allowed_clusters: ["*"]

  # Настройки анонимного доступа
  allow_anonymous_access: false
  anonymous_role: "viewer"

# Настройки UI
ui:
  refresh_interval_seconds: 15
  status_colors:
    deployment:
      healthy: "#28a745"
      progressing: "#ffc107"
      scaled_zero: "#6c757d"
      error: "#dc3545"
    pod:
      running: "#28a745"
      succeeded: "#17a2b8"
      pending: "#ffc107"
      failed: "#dc3545"
      terminating: "#6c757d"

# Настройки меню
menu:
  - id: status
    title: "Status"
    icon: "icon-status"
    required_role: "viewer"

# Настройки кэширования
cache:
  default_ttl: 30  # По умолчанию 30 секунд
  ttl:
    namespaces: 60             # Список неймспейсов кэшируется на 60 секунд
    pods: 15                   # Поды кэшируются на 15 секунд
    deployments: 20            # Деплойменты кэшируются на 20 секунд
    metrics: 10                # Метрики кэшируются всего на 10 секунд

# Настройки для тестирования
test:
  namespace_patterns: ["default", "kube-system"]  # Паттерны неймспейсов для тестирования
#+end_src
