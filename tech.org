* Описание от gemini
#+begin_quote
**Расширенное Техническое Задание: Система Мониторинга EKS Deployments & Pods**

**1. Назначение проекта**
* **Цель:** Разработка веб-приложения для визуализации состояния Deployments и Pods в кластерах AWS EKS в режиме реального времени, с учетом специфики проектов и уровней доступа компании.
* **Пользователи:** Инженеры DevOps, разработчики, QA-инженеры, менеджеры проектов (в зависимости от настроек доступа).

**2. Общие сведения**
* **Интерфейс:**
    * Современный, адаптивный (responsive) веб-интерфейс.
    * Поддержка светлой и темной тем с возможностью переключения пользователем и сохранением выбора (например, в `localStorage`).
    * Язык интерфейса: Английский.
* **Динамическое отображение:**
    * Данные обновляются автоматически без перезагрузки страницы.
    * Механизм обновления: Периодический опрос (polling) API бэкенда.
    * **Конфигурация:** Интервал обновления настраивается в конфигурационном файле (секция `ui.refresh_interval_seconds`, значение по умолчанию: 15 секунд).
* **Конфигурация:**
    * Центральный конфигурационный файл в формате YAML (`config.yaml`).
    * Структура файла должна быть четко определена (см. раздел "Конфигурация").
    * Необходимо предусмотреть возможность переопределения параметров конфигурации через переменные окружения.

**3. Функционал проекта**

**3.1. Аутентификация и Авторизация**
* **Провайдер аутентификации:** GitLab (использование OAuth 2.0 / OpenID Connect).
    * **Конфигурация:** В `config.yaml` указываются: GitLab URL, Application ID, Client Secret, Redirect URI. Секреты должны обрабатываться безопасно (например, через переменные окружения или Kubernetes Secrets).
* **Управление доступом (RBAC):**
    * Доступ к различным пунктам меню и функциям (например, просмотр определенных неймспейсов) определяется на основе членства пользователя в группах GitLab.
    * **Конфигурация:** В `config.yaml` определяется маппинг ролей приложения (например, `viewer`, `admin`) на группы GitLab. Определяются права для каждой роли (доступные пункты меню, разрешенные неймспейсы/кластеры).
    * Пример секции в `config.yaml`:
        ```yaml
        auth:
          provider: gitlab
          gitlab_url: "https://gitlab.yourcompany.com"
          client_id: "YOUR_CLIENT_ID"
          client_secret_env: "GITLAB_CLIENT_SECRET" # Имя переменной окружения
          redirect_uri: "https://your-app-url.com/auth/callback"
          roles:
            viewer:
              gitlab_groups: ["developers", "qa"]
            admin:
              gitlab_groups: ["devops-team"]
          # Права по ролям (пример)
          permissions:
            viewer:
              menu_items: ["status"]
              allowed_namespace_patterns: ["^project-.*-staging$", "^common-.*"]
              allowed_clusters: ["staging-cluster"]
            admin:
              menu_items: ["status", "admin_settings"] # Пример будущего меню
              allowed_namespace_patterns: [".*"] # Все неймспейсы
              allowed_clusters: ["*"] # Все кластеры
        ```
* **Доступ без авторизации:**
    * **Конфигурация:** В `config.yaml` (секция `auth.allow_anonymous_access`, boolean, по умолчанию `false`).
    * Если `true`, определить роль по умолчанию для анонимных пользователей (`auth.anonymous_role`, например, `viewer`), которая будет использовать соответствующие права из `auth.permissions`.
* **Сессия:** Управление сессией пользователя (например, с использованием JWT токенов, хранимых в cookie или `localStorage`).

**3.2. Пользовательский интерфейс (UI)**
* **Основная структура:**
    * Левое боковое меню навигации.
    * Возможность сворачивать/разворачивать меню (до состояния иконок). Состояние меню должно сохраняться.
    * Основная область контента для отображения выбранного пункта меню.
* **Визуализация компонентов:**
    * Deployments и Pods отображаются как прямоугольные блоки/карточки.
    * Цвет фона блока зависит от статуса компонента.
        * **Deployment:**
            * `replicas > 0` и все реплики `ready`: Зеленый (Running/Healthy)
            * `replicas > 0` но не все реплики `ready`: Желтый/Оранжевый (Progressing/Unhealthy)
            * `replicas == 0` (desired replicas): Серый/Синий (Scaled to Zero/Idle) - *Уточнение: Изначально был красный, но серый/синий может быть более подходящим для намеренно остановленного деплоймента. Красный лучше оставить для ошибок.*
            * Ошибка при получении статуса: Красный (Error)
        * **Pod:** (Если будут отображаться отдельно или при детализации)
            * `Running` или `Succeeded`: Зеленый
            * `Pending`: Желтый
            * `Failed` или `CrashLoopBackOff`: Красный
            * `Terminating`: Серый
    * **Конфигурация:** Цвета для каждого статуса должны настраиваться в `config.yaml` (секция `ui.status_colors`).
        ```yaml
        ui:
          status_colors:
            deployment:
              healthy: "#28a745" # green
              progressing: "#ffc107" # yellow
              scaled_zero: "#6c757d" # grey
              error: "#dc3545" # red
            pod:
              running: "#28a745"
              succeeded: "#17a2b8" # info blue
              pending: "#ffc107"
              failed: "#dc3545"
              terminating: "#6c757d"
          # ... другие настройки UI
        ```
* **Индикаторы:** Отображение индикаторов загрузки при получении данных и индикаторов ошибок при невозможности загрузить данные.

**3.3. Меню и Навигация**
* **Структура меню:** Определяется в `config.yaml`, что упрощает добавление новых разделов.
    ```yaml
    menu:
      - id: status
        title: "Status"
        icon: "icon-status" # Имя иконки (из выбранной библиотеки иконок)
        required_role: "viewer" # Минимальная роль для доступа
      # - id: events
      #   title: "Events"
      #   icon: "icon-events"
      #   required_role: "viewer"
      # - id: admin_settings
      #   title: "Admin Settings"
      #   icon: "icon-settings"
      #   required_role: "admin"
    ```
* **Фильтрация/Выбор контекста:**
    * В верхней части каждого раздела меню (или в глобальном хедере) должны быть элементы управления для выбора:
        * **Кластера EKS:** Выпадающий список доступных кластеров (определяются в `config.yaml` или автоматически обнаруживаются, если бэкенд имеет доступ к нескольким). Должен быть вариант "All Clusters".
        * **Неймспейса(ов):** Выпадающий список с возможностью множественного выбора (multi-select) или выбора "All Namespaces".
    * **Фильтрация неймспейсов:**
        * Список доступных неймспейсов фильтруется на основе регулярного выражения (или списка паттернов), заданного в `config.yaml` для роли пользователя (см. `auth.permissions.allowed_namespace_patterns`).
        * Пример: `^project-.*-(staging|prod)$` будет отображать неймспейсы вида `project-app1-staging`, `project-app2-prod`, но не `kube-system` или `project-app3-dev`.
    * Выбранные кластер и неймспейсы влияют на отображаемые данные в текущем разделе меню. Выбор должен сохраняться при переключении между пунктами меню (в рамках сессии пользователя).

**3.4. Пункты Меню**

* **Пункт 1: Status**
    * **Назначение:** Отображение статуса Deployments в выбранных неймспейсах и кластерах.
    * **Вид:** Сетка из прямоугольных блоков (карточек), каждый представляет один Deployment.
    * **Содержимое блока Deployment:**
        * **Цвет фона:** Соответствует статусу деплоймента (см. п. 3.2).
        * **Имя Deployment:** Отображается без суффикса `-deploy` (если он есть). Пример: `sneakers-remote-deploy` -> `sneakers-remote`. Правило удаления суффикса должно быть настраиваемым (например, список суффиксов в `config.yaml`).
        * **Реплики:** Отображение в формате `Ready/Desired` (например, `3/3`, `0/1`, `2/3`).
        * **Ключевой контейнер (основное приложение):**
            * **Имя контейнера:** Отображается без суффикса `-pod` (если он есть). Пример: `apf-sneakers-remote-pod` -> `apf-sneakers-remote`. Правило удаления суффикса также настраиваемое. *Примечание: Может потребоваться логика для определения "основного" контейнера, если их несколько.*
            * **Тэг образа:** Отображается только тэг (часть после `:`). Пример: `registry-minor:5000/wl/backend:staging-a1dcf6ff` -> `staging-a1dcf6ff`.
        * **Ресурсы Pod'ов (если Deployment активен, `Ready > 0`):**
            * Для *каждого* активного пода, управляемого этим Deployment'ом, отображать текущее потребление CPU (cores/millicores) и Memory (MiB/GiB).
            * **Требуется:** Установленный **Metrics Server** в кластере EKS для получения этих данных (`kubectl top pod`). Бэкенд должен уметь запрашивать эти метрики.
            * **Отображение:** Может быть в виде суммарных значений по всем подам или детализации по каждому поду (возможно, при наведении/клике на Deployment). Нужно уточнить UI/UX для этого.
    * **Интерактивность:** Клик по блоку Deployment может в будущем вести на страницу с более детальной информацией (поды, события и т.д.).

**4. Технические Требования и Рекомендации**

* **Бэкенд:**
    * **Язык/Фреймворк:** Clojure.
    * **Взаимодействие с EKS:** Использовать официальную клиентскую библиотеку Kubernetes для выбранного языка.
    * **Аутентификация к API Kubernetes:** Настроить Service Account в EKS с необходимыми RBAC правами (get, list, watch для Deployments, Pods; доступ к metrics.k8s.io для `kubectl top pod`). Учетные данные должны безопасно передаваться бэкенду (например, через IAM Roles for Service Accounts - IRSA).
    * **API:** Предоставить RESTful API для фронтенда для получения данных о кластерах, неймспейсах, деплойментах, подах, метриках и для процесса аутентификации.
* **Фронтенд:**
    * **Фреймворк:** На твой выбор.
    * **UI Библиотека:** Использовать готовую библиотеку компонентов (например, Material UI, Ant Design, Bootstrap) для ускорения разработки и консистентного вида.
    * **Управление состоянием:** Использовать соответствующий менеджер состояния (Redux, Vuex, Zustand и т.д.).
* **Кэширование:** Рассмотреть возможность кэширования данных от Kubernetes API на стороне бэкенда для снижения нагрузки на API сервер и ускорения ответа фронтенду, особенно при большом количестве пользователей или частых обновлениях.
* **Обработка ошибок:** Предусмотреть корректную обработку ошибок на бэкенде (недоступность API Kubernetes, ошибки парсинга, проблемы с аутентификацией) и отображение информативных сообщений на фронтенде.
* **Логирование:** Настроить структурированное логирование на бэкенде для отладки и мониторинга.

**5. Нефункциональные Требования**

* **Производительность:** Интерфейс должен оставаться отзывчивым даже при отображении данных из нескольких неймспейсов с десятками деплойментов. Время ответа API бэкенда на запросы данных не должно превышать 1-2 секунд в типичных условиях.
* **Надежность:** Приложение должно корректно обрабатывать временную недоступность Kubernetes API или Metrics Server.
* **Масштабируемость:** Бэкенд должен быть спроектирован с учетом возможного увеличения количества пользователей и отслеживаемых кластеров/неймспейсов (stateless дизайн, возможность горизонтального масштабирования подов бэкенда).
* **Безопасность:** Уделить внимание безопасности: защита секретов GitLab, безопасная настройка RBAC для Service Account, защита от распространенных веб-уязвимостей (XSS, CSRF), использование HTTPS.

**6. Развертывание**

* **Контейнеризация:** Приложение (бэкенд и фронтенд) должно быть упаковано в Docker-контейнеры.
* **Развертывание:** Рекомендуется развертывать приложение внутри одного из кластеров EKS (как Deployment и Service). Предоставить Kubernetes манифесты (Deployment, Service, Ingress, ServiceAccount, Role, RoleBinding, ConfigMap, Secret).

**7. Будущие Возможности (Вне рамок текущей версии)**

* Отображение событий Kubernetes, связанных с Deployments и Pods.
* Просмотр логов подов.
* Возможность выполнения простых действий (например, перезапуск Deployment, масштабирование).
* Более гранулярные настройки RBAC.
* Поддержка других ресурсов Kubernetes (Services, Ingresses, StatefulSets, etc.).
* Использование WebSockets или Server-Sent Events (SSE) для более эффективных real-time обновлений вместо polling.
#+end_src
* Описание проекта
#+begin_quote
# Назначение проекта
Проект предназначет для отображения информации о состоянии деплойментов и подов в кластере eks c спецификой проектов компании.

# Общие сведения
- Проект должен иметь современный web интерфейс, с возможностью переключения светлой и темной тем.
- Данные в интерфейсе должны отображаться динамически в реальном времени (должна быть настройка задержки обновления интерфейса, например обновлять каждые 15 секунд).
- В проекте должен быть конфигурационный файл в формате yaml.

# Функционал проекта
- В web интерфейс должна быть предусмотрена авторизация через gitlab.
  Доступы к различным меню должны настраиваться в конфиге, в зависимости от групп в gitlab.
  Доступ без авторизации так же настраивается в конфигурационном файле и действует по умолчанию.
- Web интерфейс должен быть на английском языке.
- Web интерфейс имеет слева меню, которое должно сворачиваться в иконки
- Отображаемые компоненты кластера (deployment, pod) должны быть прямоугольниками в цвет статуса, например
  Deployment имеет количество реплик больше 0 - зеленый, если ноль - красный.
  Цвета должны настраиваться в конфигурационном файле.
- Меню. В каждом пункте меню должен быть выбор неймспейса, одного или нескольких, кластера или всех.
  Неймспейсы должны быть отфильтрованы по regex, который настраивается в конфигурационном файле, например [*staging,alloy*].
  Так же это должно быть привязано к уровням доступа.
- Пункты меню. У нас пока один пункт, но должна быть возможность простого добавления новых (как вариант с описанием в конфигурационном файле):
  * Status - здесь отображаются деплойменты неймспейса. В прямоугольнике деплоймента (его цвет зависит от статуса) отображается:
    - имя деплоймента без префикса -deploy, например sneakers-remote-deploy должен отображаться как sneakers-remote
    - количество реплик
    - имя контейнера и тэг образа, которое берется из
      containers:
        - name: apf-sneakers-remote-pod
          image: registry-minor.wldev.app:5000/wl/backend:staging-a1dcf6ff
      имя должно быть без префикса -pod, например apf-sneakers-remote
      тэг должен быть без полного пути, например staging-a1dcf6ff
    - если у деплоймента есть реплики, то необходимо указать текущие cpu/memory по каждому запущенному поду
#+end_quote
* Test
#+begin_src clojure
  (* 2 8)
#+end_src

#+RESULTS:
: 16
